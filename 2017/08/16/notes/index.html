<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>&#39;notes&#39; | 塔奇库玛</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="面向对象基本定义 面向对象 Object-Oriented OO语言都有类的概念,而通过类可以创建多个具有相同属性和方法的对象. in for_in:遍历对象 “属性” in object:判断object是否可以访问这个属性 对象的属性能否被遍历是可以设置的?Object.defineProperty Object.defineProperty:修改属性默认的特性,ECMA5,接受三个参数:属性">
<meta name="keywords" content="notes,OO">
<meta property="og:type" content="article">
<meta property="og:title" content="&#39;notes&#39;">
<meta property="og:url" content="http://yoursite.com/2017/08/16/notes/index.html">
<meta property="og:site_name" content="塔奇库玛">
<meta property="og:description" content="面向对象基本定义 面向对象 Object-Oriented OO语言都有类的概念,而通过类可以创建多个具有相同属性和方法的对象. in for_in:遍历对象 “属性” in object:判断object是否可以访问这个属性 对象的属性能否被遍历是可以设置的?Object.defineProperty Object.defineProperty:修改属性默认的特性,ECMA5,接受三个参数:属性">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2017/08/16/notes/image/Image%204.png">
<meta property="og:image" content="http://yoursite.com/2017/08/16/notes/image/Image%207.png">
<meta property="og:image" content="http://yoursite.com/2017/08/16/notes/image/Image%205.png">
<meta property="og:image" content="http://yoursite.com/2017/08/16/notes/image/Image%206.png">
<meta property="og:image" content="http://yoursite.com/2017/08/16/notes/image/Image%208.png">
<meta property="og:updated_time" content="2017-08-16T14:39:12.661Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="&#39;notes&#39;">
<meta name="twitter:description" content="面向对象基本定义 面向对象 Object-Oriented OO语言都有类的概念,而通过类可以创建多个具有相同属性和方法的对象. in for_in:遍历对象 “属性” in object:判断object是否可以访问这个属性 对象的属性能否被遍历是可以设置的?Object.defineProperty Object.defineProperty:修改属性默认的特性,ECMA5,接受三个参数:属性">
<meta name="twitter:image" content="http://yoursite.com/2017/08/16/notes/image/Image%204.png">
  
    <link rel="alternate" href="/atom.xml" title="塔奇库玛" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">塔奇库玛</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">陀古萨是非博爱主义者 要跟塔奇库玛君道歉</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-notes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/16/notes/" class="article-date">
  <time datetime="2017-08-16T14:34:52.000Z" itemprop="datePublished">2017-08-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a>►<a class="article-category-link" href="/categories/notes/OO/">OO</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      &#39;notes&#39;
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="面向对象基本定义"><a href="#面向对象基本定义" class="headerlink" title="面向对象基本定义"></a>面向对象基本定义</h3><ul>
<li>面向对象 Object-Oriented OO语言都有类的概念,而通过类可以创建多个具有相同属性和方法的对象.</li>
<li>in<ul>
<li>for_in:遍历对象</li>
<li>“属性” in object:判断object是否可以访问这个属性</li>
<li><strong>对象的属性能否被遍历是可以设置的?Object.defineProperty</strong></li>
<li>Object.defineProperty:修改属性默认的特性,ECMA5,接受三个参数:属性所在的对象,属性的名字和一个描述符对象,,其中,描述符对象的属性必须是:configurable/enumerable/writable和value,设置其中一个或多个值,可以修改对应的特性值,如下:</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>能够具体到某一项事物上,才叫做对象;但是例如手机,指的是一类事物,就不能称为对象.</strong></p>
</li>
<li><p>new关键字是创建对象</p>
</li>
<li><p>检测对象类型:instanceof —&gt; <code>obj instanceof Object 返回true or false</code> </p>
</li>
<li><p>js中无序的键值对集合,称为对象</p>
</li>
<li><p>面向过程:解决问题的思路,专注于解决的步骤</p>
</li>
<li><p>函数封装存在的问题:1.全局变量污染(全局的函数也算是全局变量); 2. 代码结构混乱,不利于维护;  解决:放进局部,划分模块.有利于代码复用;</p>
</li>
<li><p>面向对象的三大特性:</p>
<ul>
<li><p><strong>封装;就是将功能的具体实现封装在对象内部,只对外部暴露指定接口,外界在使用对象的时候,只需要考虑接口如何使用,而不需要关系内部功能的具体实现,这就是封装.</strong></p>
</li>
<li><p><strong>继承:一个对象有一些属性和方法,另外一个对象没有,拿过来用,这就是继承;</strong></p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=&#123;&#125;;</div><div class="line"><span class="keyword">var</span> b=&#123;</div><div class="line">  money:<span class="number">100</span>,</div><div class="line">  sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//混入式继承 简单的继承操作 不推荐使用</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> b)&#123;</div><div class="line">  a[k]=b[k];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>多态;js中没有多态,强类型语言才有多态,js本身就是多态的.例如声明变量时不用指定数据类型</p>
</li>
</ul>
</li>
<li><p>创建对象的方式:</p>
<ul>
<li><p>对象字面量:var obj={};  简洁易写,复用性差</p>
</li>
<li><p>内置构造函数:new object:复用性差</p>
</li>
<li><p>自定义构造函数:复用性好</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">  <span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Person(<span class="string">"zs"</span>,<span class="number">19</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p>构造函数的执行过程:</p>
<ul>
<li>先用new关键字开辟空间,创建空对象</li>
<li>执行构造函数,将构造函数中的this指向刚刚new创建出来的对象,</li>
<li>执行构造函数中代码使用this为刚刚的对象添加属性和方法</li>
<li>默认将this,即new创建出来的对象返回,初始化对象</li>
</ul>
</li>
<li><p>构造函数的注意事项:</p>
<ul>
<li>构造函数有自己的返回值,不需要写return<ul>
<li>如果写了return, return 值类型,对默认返回值没有影响,return 引用类型,则将会返回引用类型,原先的默认值被丢弃不会返回.</li>
</ul>
</li>
<li>如果把构造函数当做普通函数调用:<ul>
<li>返回值就是return 的值,没有return,则是undefined</li>
<li>构造函数里的this指向window,给this加的属性方法都加给了window,也就相当于全局变量.</li>
</ul>
</li>
</ul>
</li>
<li><p>构造函数的特征:</p>
<ul>
<li>函数名首字母大写</li>
<li>要和new关键字一起使用</li>
<li>this指向new创建出来的对象</li>
<li>不需要写return语句,会自己默认返回new创建出来的对象</li>
<li>初始化对象</li>
<li>任何函数只要通过new操作符来调用,那它就可以作为构造函数,反之则就是个普通函数</li>
</ul>
</li>
<li><p>构造函数存在的问题:</p>
<ul>
<li><p>new新建对象,每次都会将构造函数内的函数声明copy一份,会造成内存资源浪费,</p>
<p><strong>解决方案</strong>:将函数声明从构造函数中提取出来放在全局,那这个函数声明只会执行一次,在构造函数内,将已经声明的函数地址给到方法.</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">  <span class="keyword">this</span>.age=age;</div><div class="line">  <span class="keyword">this</span>.sayHi=fnc;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnc</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>但是存在全局变量污染,所以将方法的函数放到原型里.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型  prototype"></a>原型  prototype</h3><ul>
<li><strong>新的函数</strong>在创建出来的时候,系统会直接帮忙创建一个<strong>prototype属性,这个属性是一个指针</strong>,指向一个对象,这个对象包含构造函数创建的所有实例共享的属性和方法.</li>
<li>构造函数初始化对象,调用过程是实例化,构造函数的实例即是创建后的对象,prototype的作用是:原型属性指向一个对象,原型中可以有属性和方法,可以被相关联的构造函数实例化的对象使用属性和方法.</li>
<li>访问原型:  构造函数名.prototype;</li>
<li>原型中的属性和方法是共享给实例化的对象的.实例对象指向的是同一个函数即方法;</li>
<li><strong>当调用构造函数创建一个新实例后,该实例内部将包含一个指针,指向构造函数的原型对象,即实例对象.<code>__proto__</code> .</strong></li>
<li>原型的注意 事项:<ul>
<li>原型中一般只会放一些需要被共享的内容,方法居多,属性一般不做共享</li>
<li>当使用对象访问某一个属性的时候,会先在对象自身进行查找,然后在原型链中进行查找.</li>
<li>当使用对象为某个属性进行重新赋值操作,或者新定义一个属性,则不会去原型中增删改查,只会在对象中修改增加属性,<strong>使用delete操作符可以完全删除实例属性,从而让实例能够重新访问原型中的属性.</strong></li>
<li>当对构造函数的prototype属性赋值对象时,赋值对象前后创建的实例化对象指向的原型不一样.所以一般在构造函数下面区域定义原型,固定这个区域修改,否则会导致代码难以维护</li>
</ul>
</li>
<li>原型的两种使用形式:<ul>
<li>利用对象的动态特性,为原型新增属性方法.<code>object.prototype.fn=function(){}</code> 或者<code>object.prototype[&quot;fn&quot;]=function(){}</code> </li>
<li>prototype相当于构造函数的属性,直接给prototype赋值;<code>object.prototype={}</code> ,这时构造函数名.prototype指向了新的{}.抛弃了prototype.</li>
<li>​</li>
</ul>
</li>
<li>原型的访问方式:<ul>
<li>构造函数名.prototype;</li>
<li>对象.<code>__proto__</code> 是非标准,有兼容性问题,不推荐使用</li>
</ul>
</li>
<li>原型对象中,默认会有一个<strong>constructor</strong>属性,这个属性指向的就是和此原型关联的构造函数.这个属性是系统默认给的prototype,如果prototype重新赋值新对象,新对象里没有constructor属性.一般自己手动添加constructor,指向构造函数.</li>
</ul>
<p>​</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>是个对象就有原型,原型也是对象,也有原型,这样原型组成的链式结构,称为原型链.</li>
<li><strong>一定要注意指针与值的区别,当属性值是值类型,实例修改属性会直接覆盖掉原型的属性,但是原型属性值是引用类型,则实例修改属性时会同时修改原型的属性</strong></li>
<li><code>var arr=[];</code> 的原型链是—&gt;Array()—&gt;object()—&gt;null;</li>
<li>object.prototype是js中所有对象的原型链的终点,所以他的属性和方法都可以被使用.</li>
<li>属性搜索原则:<ul>
<li>在对象自身进行查找,然后往原型链的方向寻找.直到object.prototype为止</li>
<li>实例与原型之间的连接就是一个指针而已,实例中的指针仅指向原型,不指向构造函数</li>
</ul>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="1-混入式继承"><a href="#1-混入式继承" class="headerlink" title="1.混入式继承"></a>1.混入式继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj=&#123;&#125;;</div><div class="line"><span class="keyword">var</span> obj1=&#123;</div><div class="line">  name:<span class="string">"zs"</span>,</div><div class="line">  age:<span class="number">19</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj1)&#123;</div><div class="line">  obj[k]=obj1[k];</div><div class="line">&#125;<span class="comment">//obj1变成obj的原型属性</span></div></pre></td></tr></table></figure>
<h4 id="2-原型继承-要有构造函数"><a href="#2-原型继承-要有构造函数" class="headerlink" title="2.原型继承(要有构造函数)"></a>2.原型继承(要有构造函数)</h4><p>2.1利用混入的方式,将要继承的对象的所有的属性和方法添加到当前对象的原型中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  </div><div class="line">&#125;<span class="comment">//先有一个构造函数</span></div><div class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Person();<span class="comment">//实例化对象</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1=&#123;</div><div class="line">  name:<span class="string">"zs"</span>,</div><div class="line">  age:<span class="number">19</span>,</div><div class="line">  make:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"hehe"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//将obj1的方法属性加到obj的原型中</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</div><div class="line">  Pesron.prototype[k]=obj[k];</div><div class="line">&#125;</div><div class="line"><span class="comment">//完成原型继承</span></div><div class="line"><span class="comment">//验证:</span></div><div class="line"><span class="built_in">console</span>.log(obj.make);</div></pre></td></tr></table></figure>
<p>2.2 直接将要继承的对象作为当前对象的原型,原型的意义就是拿来继承的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person.prototype=obj1;<span class="comment">//构造函数指向原型的指针已经变了</span></div><div class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(obj.make);</div></pre></td></tr></table></figure>
<h4 id="3-Object-create-经典继承"><a href="#3-Object-create-经典继承" class="headerlink" title="3  Object.create(); 经典继承"></a>3  Object.create(); 经典继承</h4><p>Object.creat():将上述的继承方法封装,原理同上.内部实现一样.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj= <span class="built_in">Object</span>.creat(<span class="string">"要继承的对象"</span>);</div><div class="line"><span class="comment">//Object.creat()方法可以用来创建一个对象,这个对象的原型就是参数,</span></div><div class="line"><span class="comment">//其实就是将参数中传入的对象,作为了新对象的原型.</span></div></pre></td></tr></table></figure>
<p>此方法ECMA5.1才有,所以有兼容性问题.这时需要自己封装这个函数使用,jQuery的create方法效率比我们自己封装的高.所以优先使用jQuery的方法.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCreat</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">Object</span>.creat)&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.creat(obj);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  F.prototype=obj;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h3><p>Object的prototype属性是唯读的,但是可以往这个原型对象里添加属性方法.<code>Object.prototype.extend=function(){}</code> </p>
<p>jQuery的extend方法是将一个或多个对象的内容合并到目标对象,若只有一个参数,则合并到jQuery中去</p>
<h3 id="如何安全的扩展内置对象"><a href="#如何安全的扩展内置对象" class="headerlink" title="如何安全的扩展内置对象"></a>如何安全的扩展内置对象</h3><p><strong>jQuery中加插件是<code>jQuery.fn.myExtend=function(){}</code></strong> </p>
<p> 自定义</p>
<p>将sum方法加进我自己的数组方法中,可以用继承来将内置数组原型的属性方法拿到后,在自定义的数组中加入我自己的属性方法.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">MyArray.prototype=[];</div><div class="line">MyArray.prototype.sum=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> arr= <span class="keyword">new</span> MyArray();</div><div class="line"><span class="built_in">console</span>.log(arr.sum());</div></pre></td></tr></table></figure>
<p><img src="image/Image 4.png" alt=""></p>
<h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>Object.prototype是js中所有对象的源,所有对象都可以用他的属性方法.</p>
<h5 id="1-obj-hasOwnPrototype-“属性”"><a href="#1-obj-hasOwnPrototype-“属性”" class="headerlink" title="1. obj.hasOwnPrototype(“属性”);"></a>1. obj.hasOwnPrototype(“属性”);</h5><p>obj中,”属性”是否是自己的属性</p>
<h5 id="2-obj-isPrototypeOf-“另一个对象”"><a href="#2-obj-isPrototypeOf-“另一个对象”" class="headerlink" title="2. obj.isPrototypeOf(“另一个对象”)"></a>2. obj.isPrototypeOf(“另一个对象”)</h5><p>判断obj是否是另一个对象的原型</p>
<h5 id="3-prototypeIsEnumerable"><a href="#3-prototypeIsEnumerable" class="headerlink" title="3. prototypeIsEnumerable()"></a>3. prototypeIsEnumerable()</h5><p>属性是否可被枚举(遍历);被for_in遍历到.prototypeEnumerable(“属性名”)首先判断属性是否属于对象本身,然后再判断能否被for_in遍历,</p>
<h5 id="4-toLocaleString-toString"><a href="#4-toLocaleString-toString" class="headerlink" title="4. toLocaleString  /  toString"></a>4. toLocaleString  /  toString</h5><p>Date()对象等,跟区域差异有关的,两者打印出来的都不相同</p>
<p>toString打印出来的就是通用格式,toLocaleString打印的是本地格式,从电脑设置里获取区域信息.</p>
<p>[object Object]—&gt;[typeof 构造函数名称]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj=&#123;&#125;;</div><div class="line">obj.toString();<span class="comment">//[object Object]</span></div><div class="line"><span class="keyword">var</span> arr=[];</div><div class="line">arr.toString();<span class="comment">//空,数组直接调用的是自己原型中的tostring方法,所以要调用Object的toString方法.如下</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(arr);<span class="comment">//[object Array];</span></div></pre></td></tr></table></figure>
<h5 id="5-valueOf-获取对象的值"><a href="#5-valueOf-获取对象的值" class="headerlink" title="5. valueOf() 获取对象的值"></a>5. valueOf() 获取对象的值</h5><p>当引用类型和值类型数据运算的时候,会先调用valueOf方法,尝试使用返回值运算,如果不能运算,就继续调用toString方法获取返回值运算.</p>
<h3 id="创建函数的方式"><a href="#创建函数的方式" class="headerlink" title="创建函数的方式"></a>创建函数的方式</h3><h4 id="1-创建函数的方式"><a href="#1-创建函数的方式" class="headerlink" title="1. 创建函数的方式"></a>1. 创建函数的方式</h4><p>1.1函数声明:<code>function函数名(){}</code></p>
<p>1.2函数表达式<code>var 函数名=function(){}</code></p>
<p>1.3通过Function构造函数创建<code>var 函数名=new Function();</code> </p>
<h4 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h4><p><strong>函数拥有双重身份,函数和对象,都可以生效,</strong></p>
<p>函数:可以被调用</p>
<p>对象:拥有对象的一切特性</p>
<p>构造函数:可以用来初始化对象</p>
<p>js中所有函数都有原型属性,    </p>
<h4 id="3-Function的使用说明"><a href="#3-Function的使用说明" class="headerlink" title="3. Function的使用说明"></a>3. Function的使用说明</h4><p>js中所有的函数都可以认为是Function的实例,Function是js中所有函数对象的构造函数.</p>
<p>Function的使用</p>
<p>1.不传递参数:创建了空函数</p>
<ol>
<li><p>传递一个参数:<code>var fn=new Function(&quot;console.log(&#39;hehe&#39;);alert(&#39;haha&#39;)&quot;)</code> 参数是字符串,可被当做函数体用js语法识别.</p>
</li>
<li><p>传递形参:传递多个参数,最后一个参数被当做函数体使用,前面的参数都会被当做形参.所有参数都是字符串.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a+b;"</span>);</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>字符串里换行:\和``,<strong>ES6的模板字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="string">"ab\</span></div><div class="line"><span class="string">c"</span>;</div><div class="line"><span class="keyword">var</span> b=<span class="string">`abcd</span></div><div class="line"><span class="string">edf`</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h4><p>是一个全局函数,可以将字符串转换成js代码并直接运行</p>
<p>用来实现四则运算很简单,但是存在安全问题</p>
<p>eval和Function都有安全性问题,所以一般情况下不会使用,毕竟字符串识别转代码,可实现xss攻击.而且两者还会影响浏览器性能优化,编译器无法优化eval的上下文.</p>
<p>json格式字符串转js对象的时候,因为JSON.parse()有兼容性问题,如果直接用eval来转换json格式字符串.会报错,</p>
<p><strong>{}花括号不仅可以表示对象还可以表示代码段,单独使用{}的时候,里面的东西会被当做代码段处理,所以会报语法错误</strong></p>
<p>解决:只要将eval将json字符串中的{}当做对象字面量处理即可.<code>eval(&quot;var hcc=&quot;+jsonString)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonString=<span class="string">'&#123;"name":"hcc","age":15&#125;'</span>;</div><div class="line"><span class="comment">//第一个</span></div><div class="line"><span class="built_in">eval</span>(<span class="string">"var hcc="</span>+jsonString);</div><div class="line"><span class="comment">//第二个</span></div><div class="line"><span class="built_in">eval</span>(<span class="string">"("</span>+jsonString+<span class="string">")"</span>);</div></pre></td></tr></table></figure>
<h4 id="函数作对象的时候-分析函数对象的原型关系"><a href="#函数作对象的时候-分析函数对象的原型关系" class="headerlink" title="函数作对象的时候,分析函数对象的原型关系"></a>函数作对象的时候,分析函数对象的原型关系</h4><p>函数当做对象来处理时,形同Date()的原型链;</p>
<h5 id="函数对象常见的属性"><a href="#函数对象常见的属性" class="headerlink" title="函数对象常见的属性"></a>函数对象常见的属性</h5><p><code>function Person(){} console.dir(Person)</code> 可查看函数的属性;</p>
<p><strong>name属性:在函数表达式中,函数名是不能在外面拿来调用函数的,但是可以在函数内部使用,可写递归函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn=<span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(sayHello);<span class="comment">//打印出函数体</span></div><div class="line">&#125;</div><div class="line">fn.name;<span class="comment">//sayHello</span></div><div class="line">sayHello();<span class="comment">//报错</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn=<span class="keyword">new</span> <span class="built_in">Function</span>();</div><div class="line">fn.name;<span class="comment">//anonymity匿名函数</span></div></pre></td></tr></table></figure>
<p><strong>length属性,表示当前函数的形参个数;</strong></p>
<p>arguments属性:<code>fn.arguments</code> 和arguments对象一样的功能,但是这个属性只能在函数内部获取到值.都是盛放所有传入参数的伪数组.</p>
<p>caller属性:<code>fn.caller</code> 必须在函数内部调用,才能获取到值,当前函数是在哪个函数中调用的,caller指的就是这个外面的函数,如果是全局调用,caller指的是null.不过已经快废弃了.</p>
<h5 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h5><p>arguments是函数内部的一个局部变量,所以只能在函数内使用;</p>
<p>arguments是伪数组,不能使用数组的方法,当函数调用的时候,arguments对象会将所有传入的实参存入到自身;</p>
<p>arguments.length:传入实参个数;</p>
<p>arguments.callee:指的是当前函数本身;可以自调用,匿名函数可用,或者函数名被占用的情况;可辅助实现函数的递归;但是严格模式下不支持;</p>
<p><strong>在严格模式下不能通过脚本访问arguments.callee,这时用命名函数表达式来解决:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factorial=(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(num&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> num*f(num<span class="number">-1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//即使函数名被占用,也没事,函数名f依旧生效,这种模式在严格和非严格模式都生效.</span></div></pre></td></tr></table></figure>
<p><strong>函数的重载:函数名相同,参数不一致的函数,称为重载.</strong> 重载就是为了实现传入的参数不同,功能不同.例如jQuery的css()方法.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用arguments实现函数重载</span></div><div class="line"><span class="keyword">var</span> obj=&#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//设置值的操作</span></div><div class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">2</span>)&#123;</div><div class="line">    obj[<span class="built_in">arguments</span>[<span class="number">0</span>]]=<span class="built_in">arguments</span>[<span class="number">1</span>];</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> obj[<span class="built_in">arguments</span>[<span class="number">0</span>]];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">value(<span class="string">"key"</span>,<span class="string">"value"</span>);</div><div class="line">value(<span class="string">"key"</span>);</div><div class="line"><span class="comment">//实现了输入一个参数获取值,输入两个参数设置值的功能,模仿css()方法</span></div></pre></td></tr></table></figure>
<h5 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h5><p>拥有数组的访问形式,也有length属性(<strong>必须有length属性才能被遍历)</strong>可以被for循环遍历,但是<strong>没有数组的方法</strong>. 伪数组的length是固定的不会自动变化,需要手动 进行修改</p>
<h3 id="函数完整原型链"><a href="#函数完整原型链" class="headerlink" title="函数完整原型链"></a>函数完整原型链</h3><p>作业:画出函数的完整原型链:内置对象都是由Function构造函数实例化出来的,例如Array(),Date(),Function()本身</p>
<p><img src="image/Image 7.png" alt=""></p>
<h5 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h5><p>定义:对象是否是构造函数的实例对象.</p>
<p>语法:对象 instanceof 构造函数</p>
<p>功能:判断构造函数的prototype属性所指的对象是否在对象的原型链上,</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></div></pre></td></tr></table></figure>
<h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><p>浅拷贝在copy对象时,属性是复制后另起一份,但是遇到方法时还是会copy地址,所以copy出来的备份不是完全copy,原对象的方法和copy对象的方法地址相同指向同一个方法对象,称为浅拷贝;一层复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hcc = &#123;</div><div class="line">  name:<span class="string">"hcc"</span>,</div><div class="line">  age:<span class="number">17</span>,</div><div class="line">  car:&#123;</div><div class="line">    brand:<span class="string">"布加迪"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//浅拷贝:将对象的属性复制一份,不考虑对象内部的引用类型的属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span> (<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> result=&#123;&#125;;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</div><div class="line">    result[k]=obj[k];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> shallowObj=shallowCopy(hcc);</div><div class="line"><span class="comment">//car并没有复制另一份,而是指向原对象的car对象</span></div></pre></td></tr></table></figure>
<p>深拷贝是完全另一个对象,跟原本对象完全没关系.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hcc = &#123;</div><div class="line">  name:<span class="string">"hcc"</span>,</div><div class="line">  age:<span class="number">17</span>,</div><div class="line">  car:&#123;</div><div class="line">    brand:<span class="string">"布加迪"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//深拷贝:复制时将所有属性另起一份,包括引用类型属性,而且两个对象互不影响</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span> (<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> result=&#123;&#125;;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[k] == <span class="string">"object"</span>)&#123;</div><div class="line">      <span class="comment">//要将这个属性再次复制</span></div><div class="line">      <span class="comment">/*var temp=&#123;&#125;;</span></div><div class="line"><span class="comment">      for(var j in obj[k])&#123;</span></div><div class="line"><span class="comment">        temp[j]=obj[k][j];</span></div><div class="line"><span class="comment">      &#125;</span></div><div class="line"><span class="comment">      result[k]=temp;*/</span></div><div class="line">      <span class="comment">//递归实现</span></div><div class="line">      result[k]=deepCopy(obj[k]);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">//值类型的属性直接复制</span></div><div class="line">    result[k]=obj[k];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> shallowObj=shallowCopy(hcc);</div><div class="line"><span class="comment">//car并没有复制另一份,而是指向原对象的car对象</span></div></pre></td></tr></table></figure>
<p>学习网址:<a href="http://risky.love/2016/10/08/JavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">http://risky.love/2016/10/08/JavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0/</a></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>函数内部直接或间接的调用自己,递归存在性能低下问题,但是面试题喜欢考,而且面试喜欢考算法题和js逻辑题.</p>
<p><strong>两大要素:1.必须有自己调用自己.2.必须要有结束条件,而且调用几次就留几个出口?</strong> </p>
<p>化归思想:转化和归结</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//求n的阶乘</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">num</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> num(n<span class="number">-1</span>)*n;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(num(<span class="number">3</span>));</div><div class="line"></div><div class="line"><span class="comment">//求幂 n的m次方</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mi</span>(<span class="params">n,m</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(m&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</div><div class="line">  <span class="keyword">return</span> n*mi(n,m<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(mi(<span class="number">3</span>,<span class="number">2</span>));</div><div class="line"></div><div class="line"><span class="comment">//斐波那契数列</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(n==<span class="number">1</span> ||n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>)+fibonacci(n<span class="number">-2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>面试题:用递归获取页面元素的一种思想</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作业:获取body中所有元素 递归实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElements</span>(<span class="params">ele</span>) </span>&#123;</div><div class="line">    <span class="comment">//新建数组盛放子元素</span></div><div class="line">    <span class="keyword">var</span> list=[];</div><div class="line">    <span class="comment">//先找到第一层的子元素</span></div><div class="line">    <span class="keyword">var</span> children=ele.children;</div><div class="line">    <span class="comment">//遍历第一层的子元素</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++)&#123;</div><div class="line">      <span class="comment">//将第一层子元素放入数组</span></div><div class="line">        <span class="keyword">var</span> child=children[i];</div><div class="line">        list.push(child);</div><div class="line">      </div><div class="line">      <span class="comment">//children[i]还有子元素,递归返回第二层子元素</span></div><div class="line">      <span class="keyword">var</span> childList=getElements(child);</div><div class="line">      <span class="comment">//将拿到的第二层子元素集合,合并到当前数组中</span></div><div class="line">      list=list.concat(childList);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> list;<span class="comment">//返回数组</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(getElements(<span class="built_in">document</span>.body));</div></pre></td></tr></table></figure>
<p>解析图如下:</p>
<p><img src="image/Image 5.png" alt=""></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><strong>js中有且只有函数可以创造作用域. </strong> </p>
<p><strong>js中没有块级作用域,在代码块中限定的作用域就是块级作用域.匿名函数可以用来模仿块级作用域.即匿名函数自调用,<code>(function(){})();</code></strong> </p>
<p><strong>js中只有词法作用域.</strong>?</p>
<p>作用域分为2种:1.动态作用域.2.静态作用域(词法作用域);</p>
<p><strong>词法作用域</strong>:访问的变量只和当前代码的声明有关,和具体调用运行没有关系,只要代码写好,那么访问的变量就确定了.不管有无执行.</p>
<p>js代码执行分两个阶段:预解析阶段和执行阶段;</p>
<p><strong>变量提升是提升到其所在的作用域顶端.</strong></p>
<h4 id="变量提升中特殊情况处理"><a href="#变量提升中特殊情况处理" class="headerlink" title="变量提升中特殊情况处理:"></a>变量提升中特殊情况处理:</h4><ol>
<li><p>函数和变量同名—&gt;只会提升函数声明,变量的声明直接忽略(var不要了)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> a=<span class="number">10</span>;</div><div class="line"><span class="comment">//声明提升后如下</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a=<span class="number">10</span>;<span class="comment">//变量声明被忽略,即丢掉var</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>2.变量的提升是分作用域的!</p>
<p>3.变量提升是分段的 (script标签);参考jQuery引用的状况.</p>
<p>​    <strong>当前script标签中的所有变量声明和函数声明,都只会被提升到当前标签的最顶上.</strong> </p>
<p>4.函数表达式不能被提升.<code>var fn=function(){}</code> 提升的是变量<code>var fn</code>;</p>
<p>5.条件式函数声明:</p>
<p>​    <strong>在条件语句中声明的函数,在提升的时候会被当做函数表达式处理,最后只会提升函数名称,不会提升函数体.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">test();<span class="comment">//报错,不会提升函数</span></div><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"打印"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如上函数形同以下</span></div><div class="line">  <span class="keyword">var</span> test=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"打印"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//最后提升写法如下:</span></div><div class="line"><span class="keyword">var</span> test;</div><div class="line">test();</div><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">  test=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//面试题</span></div><div class="line"><span class="keyword">if</span> (<span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">  &#125;</div><div class="line">  alert(a);<span class="comment">//10</span></div><div class="line"> <span class="comment">//提升后如下</span></div><div class="line">    <span class="keyword">var</span> a;</div><div class="line">    <span class="keyword">if</span>(<span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>) a=<span class="number">10</span>;</div><div class="line">    alert(a);<span class="comment">//10</span></div></pre></td></tr></table></figure>
<p>6.函数中形参的声明以及赋值的过程,是在预解析之前,且不参与预解析过程.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="comment">//var a=10;//实参传入,放在最前面,并且不参与预解析</span></div><div class="line">  <span class="built_in">console</span>.log(a);</div><div class="line">  <span class="keyword">var</span> a=<span class="number">10</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line">test(<span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>思路:变量提升—&gt;作用域分析—&gt;做题</p>
<p><code>!&quot;a&quot;</code> 转化为布尔值 false;<code>var foo;  !foo==!undefined==true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo=<span class="number">12</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(!foo)&#123;</div><div class="line">  <span class="keyword">var</span> foo=<span class="number">10</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo);</div><div class="line">&#125;</div><div class="line">fn();<span class="comment">//10</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作业 : 面试题必须熟练</span></div><div class="line"><span class="comment">//函数直接调用,返回this指向window</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">1</span>); &#125;;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="number">2</span>); &#125;;</div><div class="line">   Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">3</span>); &#125;;</div><div class="line">   <span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="number">4</span>); &#125;;</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">5</span>); &#125;</div><div class="line"> </div><div class="line">   Foo.getName(); <span class="comment">// 2</span></div><div class="line">   getName(); <span class="comment">// 4</span></div><div class="line">   Foo().getName(); <span class="comment">// 1 Foo()直接调用返回this指向window</span></div><div class="line">   getName(); <span class="comment">// 1</span></div><div class="line">   <span class="keyword">new</span> Foo.getName(); <span class="comment">// 2</span></div><div class="line">   <span class="keyword">new</span> Foo().getName(); <span class="comment">// 3  形同var obj=new Foo(); obj.getName();--&gt;新建空对象,Foo中并没有this指向getName函数,所以去原型链中找getName函数</span></div><div class="line">   <span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 3  形同var obj=new Foo(); new obj.getName();</span></div></pre></td></tr></table></figure>
<p>​    <img src="image/Image 6.png" alt=""></p>
<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>函数可以创建作用域,函数中也可以声明函数,形成<strong>作用域嵌套作用域,自内向外访问的链式结构</strong>,称为作用域链.</p>
<p>变量搜索原则:当使用变量的时候遵守如下原则:    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> 	1. 会在当前使用该变量的作用域中,查找该变量(var声明).</div><div class="line">2. 如果没找到,就沿着作用域链往上查找,直到全局作用域.</div></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>一种封闭的包裹结构</p>
<p>由于作用域的关系,函数中声明的变量无法在函数外部访问.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//闭包的经典模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> num=<span class="number">10</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> inner;<span class="comment">//返回内部函数 引用类型 返回地址</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fn=test();<span class="comment">//在外部访问内部函数 获取地址 指向内存中的内部函数</span></div><div class="line">fn();</div></pre></td></tr></table></figure>
<p><strong>闭包:指的是能够访问独立的变量的函数</strong> .变量在本地使用,但是定义在封闭的作用域中.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如何通过闭包实现获取设置数据操作</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> num=<span class="number">123</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    getNum:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> num; &#125;,</div><div class="line">    setNum:<span class="function"><span class="keyword">function</span>(<span class="params">pra</span>)</span>&#123; num=pra;  &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//获取:</span></div><div class="line">test().getNum();</div><div class="line"><span class="comment">//设置:</span></div><div class="line">test().setNum();</div></pre></td></tr></table></figure>
<p><strong>同一个函数每被调用一次就开辟一块空间,相互之间无联系,</strong></p>
<p>闭包外部函数调用多次的情况:</p>
<p>​    <strong>一般情况下,外部函数只需调用一次</strong>,这样可以确保我们访问的是同一个数据,若外部函数多次调用,那么我们访问的数据就不是同一份了.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> num=<span class="built_in">Math</span>.random();</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> inner;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fn=outer();<span class="comment">//fn不管调用多少次 拿到的num值都一样 因为outer函数就执行了一次</span></div><div class="line"></div><div class="line">outer()();</div><div class="line">outer()();<span class="comment">//outer函数多次调用 开辟多个空间 相互之间无联系 所以两者值不一样</span></div></pre></td></tr></table></figure>
<p>闭包应用:</p>
<p>​    闭包会导致内存泄漏,因为闭包的函数一直被占用,所以内存一直被占用.但是闭包可实现基本语法无法实现的特效.但是慎用闭包.存在性能问题.</p>
<ol>
<li><p><strong>闭包可以用来保护变量;</strong></p>
</li>
<li><p><strong>可以为函数设置私有变量;防止全局变量污染</strong>;参考之前的查找body所有子元素的案例,里面的list变量就是函数的私有变量.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> data;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">  <span class="keyword">return</span> test;<span class="comment">//data是test函数的私有变量</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//私有变量解决循环注册点击事件</span></div><div class="line"><span class="comment">//函数运行完才会继续往下执行代码 参数是页面被点击元素集合数组</span></div><div class="line"><span class="comment">//讲道理 还是用自定义下标index来注册点击事件</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIndex</span>(<span class="params">eles</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; eles.length; i++) &#123;</div><div class="line">      eles[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">"当前点击的是第"</span> + j + <span class="string">"个div"</span>);</div><div class="line">        &#125;;</div><div class="line">      &#125;(i);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p><strong>循环中setTimeout的问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//打印0-9</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTime</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;      </div><div class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log(j);</div><div class="line">        &#125;,<span class="number">1000</span>)</div><div class="line">      &#125;)(i);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>补充:js是单线程的,</strong>所有任务都得依次执行;主线程:所有正常从上往下执行的代码.次要线程:setTimeout/setInterval/事件回调都是次要任务.</p>
<p>事件队列:次要任务放进事件队列里,等待主线程完成后,再依次执行事件队列里的任务.</p>
</li>
</ol>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>cache:缓存,临时存储,作用就是提升效率;</p>
<ol>
<li><p>浏览器缓存:</p>
<p>浏览器输入网址—&gt;服务器接受请求后返回html文件—&gt;浏览器分析html并渲染,遇到外部资源(js图片等文件)—&gt;重新向服务器请求这些文件.</p>
<p>​浏览器缓存区域会存储一些网站的外部资源.但是没法及时更新这些资源,解决:<strong>更新的文件重新命名,加版本号</strong>,客户端就会再次请求新的文件;</p>
</li>
<li><p>CDN    Content Delivery Network  内容分发网络</p>
<p>​    CDN 服务提供商,加速网站文件加载,</p>
</li>
<li><p>硬件缓存 : </p>
<p>​    内存,就是在硬盘和CPU之间将数据进行缓存,因为CPU直接从硬盘读取数据太慢了,所以现将数据缓存到内存中,再由CPU从内存中获取数据,会大大提高读取效率.</p>
<p><strong>Linux开源系统,免费;Unix收费,企业用系统;Windows 7等是个人操作系统,Windows 2004等是sever操作系统.</strong></p>
</li>
<li><p>数据库缓存</p>
<p>​    MySQL( 免费)  MSSQL  Oracle :硬盘型数据库,</p>
<p>​    MongoDB   Redis  :内存型数据库;</p>
<p>​    先往内存型数据库中存储,这样快,然后再往硬盘数据库挪数据.</p>
</li>
</ol>
<h5 id="js中缓存的使用"><a href="#js中缓存的使用" class="headerlink" title="js中缓存的使用"></a>js中缓存的使用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//做一个缓存容器,实现功能:存储和获取数据;容器安全不被污染;内存有大小限制存储数据的数量.</span></div><div class="line"><span class="comment">//内容大小判断:用空数组存放key值,判断数组长度来限制</span></div><div class="line"><span class="comment">//作业:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatCache</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cache = &#123;&#125;;<span class="comment">//容器</span></div><div class="line">    <span class="keyword">var</span> list=[];<span class="comment">//存放容器对象的key值 用来判断容器的大小</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (value)&#123;</div><div class="line">        <span class="keyword">if</span>(list.length&gt;=<span class="number">3</span>)&#123;</div><div class="line">          <span class="keyword">delete</span> cache[list.shift()];</div><div class="line">        &#125;</div><div class="line">        list.push(key);</div><div class="line">        cache[key] = value;</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> cache[key];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> cache=creatCache();<span class="comment">//只能开一个createCache函数</span></div><div class="line"> cache(<span class="string">"zs"</span>,<span class="number">11</span>);</div><div class="line"> cache(<span class="string">"zx"</span>,<span class="number">12</span>);</div><div class="line"> cache(<span class="string">"ze"</span>,<span class="number">13</span>);</div><div class="line"> cache(<span class="string">"zd"</span>,<span class="number">14</span>);</div><div class="line"> cache(<span class="string">"zc"</span>,<span class="number">15</span>);</div><div class="line">  </div><div class="line">  <span class="built_in">console</span>.log(cache(<span class="string">"zd"</span>));</div></pre></td></tr></table></figure>
<p><strong>缓存容器应用</strong>:斐波那契数列性能问题原因是重复代码太多;缓存可以存储已经计算好的函数结果,下次请求可以直接获取结果,这样避免函数重复开辟空间计算.</p>
<h5 id="斐波那契数列计算用缓存容器优化计算过程"><a href="#斐波那契数列计算用缓存容器优化计算过程" class="headerlink" title="斐波那契数列计算用缓存容器优化计算过程"></a>斐波那契数列计算用缓存容器优化计算过程</h5><p><img src="image/Image 8.png" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作业:斐波那契数列计算用缓存容器优化计算过程</span></div><div class="line"><span class="comment">//使用缓存容器存放计算好的函数结果,避免重复计算同一个函数 如下图</span></div><div class="line"><span class="comment">//引用之前封装好的函数,缓存容器长度最小是3,即存放n和n-1,n-2的计算结果就行了.</span></div><div class="line">  <span class="keyword">var</span> cache=creatCache();<span class="comment">//放在函数计算外面,不然每次都是新的缓存盒子存储一个数据而已</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fibo</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">      <span class="comment">//先在缓存盒子里找下是否有值</span></div><div class="line">      <span class="keyword">var</span> num=cache(n);</div><div class="line">      <span class="keyword">if</span>(num)&#123;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) &#123;</div><div class="line">          num=<span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">          num=fibo(n<span class="number">-1</span>)+fibo(n<span class="number">-2</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将计算好的值存入缓存盒子中</span></div><div class="line">        cache(n,num);</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(fibo(<span class="number">500</span>));</div></pre></td></tr></table></figure>
<h5 id="jQuery缓存源码"><a href="#jQuery缓存源码" class="headerlink" title="jQuery缓存源码"></a>jQuery缓存源码</h5><p>jQuery优秀的缓存代码:</p>
<p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在函数内部存储key值加空格" "---&gt;key+" "---&gt;避免了存入关键字跟函数本身的属性名冲突</span></div><div class="line"><span class="comment">//作业:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCache</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> keys = [];</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">cache</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span>(keys.push(key + <span class="string">" "</span>) &gt; <span class="number">20</span>)&#123;</div><div class="line">                    <span class="keyword">delete</span> cache[keys.shift()];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> (cache[key + <span class="string">" "</span>] = value);<span class="comment">//return只是让函数有个返回值,返回值是表达式的等式后面的value值</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> cache;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">var</span> cache = createCache();</div></pre></td></tr></table></figure>
<h3 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h3><p>立即执行函数表达式(自调用函数)—&gt;ITEF immediately invoked function expression</p>
<p>只要能够让系统将这个函数当做一个表达式,就可以调用;把函数作为句子的一部分,系统就会把函数当做表达式.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)();</div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</div><div class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</div><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</div><div class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</div></pre></td></tr></table></figure>
<p><strong>立即执行函数的前后分号一定要加上。</strong> </p>
<h5 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h5><p>就是自调用函数,作用是隔离;</p>
<p><strong>一般情况下,会将所有在沙箱中用到的外部内容,全部以传参的形式给到沙箱里;</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//沙箱基本模式</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">外部内容形参</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> num=<span class="number">1</span>;<span class="comment">//变量声明</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//功能实现</span></div><div class="line">  </div><div class="line">  <span class="built_in">window</span>.test=test;<span class="comment">//如果需要就将内部的函数暴露到全局,暴露接口</span></div><div class="line">&#125;)(外部内容实参);<span class="comment">//外部内容传入,例如window</span></div><div class="line"><span class="comment">//如果需要使用外部内容,就当做参数传进去</span></div></pre></td></tr></table></figure>
<p>为什么要把window之类的当做参数传到沙箱内部?</p>
<p>​    <strong>实现逻辑上的隔离;有利于代码压缩;</strong></p>
<p>代码压缩:内置对象是无法被压缩的,但是传参形式的内置对象名可以被压缩.</p>
<h5 id="数组的高级方法"><a href="#数组的高级方法" class="headerlink" title="数组的高级方法"></a>数组的高级方法</h5><p><strong>在mdn里搜索Array.prototype.filter</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//语法:</span></div><div class="line"><span class="keyword">var</span> new_array = arr.filter(callback[, thisArg])</div><div class="line"><span class="comment">//参数</span></div><div class="line">	<span class="comment">//callback</span></div><div class="line">        <span class="comment">//用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。</span></div><div class="line">        <span class="comment">//返回true表示保留该元素（通过测试），false则不保留。</span></div><div class="line">	<span class="comment">//thisArg</span></div><div class="line">		<span class="comment">//可选。执行 callback 时的用于 this 的值。</span></div><div class="line">	<span class="comment">//返回值</span></div><div class="line">      	<span class="comment">//一个新的通过测试的元素的集合的数组</span></div></pre></td></tr></table></figure>
<ol>
<li><p>数组的forEach(fn); —&gt;参考jQuery的each()方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//语法:</span></div><div class="line">  arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;<span class="comment">//调用次数等于数组长度</span></div><div class="line">    <span class="comment">//value:当前正在遍历的数组元素</span></div><div class="line">	<span class="comment">//index:当前遍历元素的下标</span></div><div class="line">	<span class="comment">//arr:当前正在遍历的数组</span></div><div class="line">  &#125;)</div><div class="line"><span class="comment">//原理实现:</span></div><div class="line">  <span class="built_in">Array</span>.prototype.myForEach = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</div><div class="line">      callback(<span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  arr.myForEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;<span class="comment">//callback的实参</span></div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>map方法 映射</p>
<ol>
<li>map方法和forEach一样,也可以用来遍历数组;</li>
</ol>
<p>区别:<strong>map方法有返回值且是一个数组,数组中存放的是回调函数每次被调用后的返回值.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//语法:</span></div><div class="line">  arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,arr</span>)</span>&#123;</div><div class="line">    <span class="comment">//value:当前正在遍历的数组元素</span></div><div class="line">	<span class="comment">//index:当前遍历元素的下标</span></div><div class="line">	<span class="comment">//arr:当前正在遍历的数组</span></div><div class="line">  &#125;)</div><div class="line">  <span class="comment">//有返回值</span></div><div class="line">  <span class="keyword">var</span> result=arr.map(fn);</div><div class="line">  <span class="comment">//原理实现:</span></div><div class="line">  <span class="built_in">Array</span>.prototype.myMap=<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> temp=[];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++)&#123;</div><div class="line">      temp.push(callback(<span class="keyword">this</span>[i],i,<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> temp;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>every()—&gt;判断数组中所有元素是否都满足某个条件,找false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//every 返回值是true false</span></div><div class="line"><span class="comment">//判断数组中所有元素是否都满足某个条件</span></div><div class="line"><span class="keyword">var</span> flag=arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">v,i,arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> v&gt;<span class="number">5</span>;<span class="comment">//判断所有数组元素都大于5?是的返回true,否则false</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>some()—&gt;判断数组中是否有任意元素满足条件,满足一个就返回true,找true.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//some 返回值是true false</span></div><div class="line"><span class="comment">//判断数组中是否有满足条件的值,满足一个就返回true</span></div><div class="line"><span class="keyword">var</span> flag=arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">v,i,arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> v&gt;<span class="number">5</span>;<span class="comment">//判断数组是否有大于5的元素.</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h5 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h5><p>可以帮对象添加属性,并设置这个属性的特性(能否被删除,遍历,赋值..)还可以用来修改已经有的属性的特性;</p>
<p>如果对象中不存在指定的属性，<code>Object.defineProperty()</code>就创建这个属性。</p>
<p><strong>用来监视对象的属性赋值修改等状态</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//语法:</span></div><div class="line"><span class="comment">//Object.definePrototype(要添加属性的对象,要添加的属性名,属性的描述信息(特性对象)):</span></div><div class="line"><span class="built_in">Object</span>.definePrototype(obj,<span class="string">"name"</span>,&#123;</div><div class="line">  writable:<span class="literal">false</span>,<span class="comment">//当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。</span></div><div class="line">  configurable:<span class="literal">false</span>,<span class="comment">//当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</span></div><div class="line">  enumerable:<span class="literal">false</span>,<span class="comment">//当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</span></div><div class="line">  value:<span class="string">"hucc"</span>,<span class="comment">//该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</span></div><div class="line">  <span class="comment">//重点:</span></div><div class="line">  <span class="comment">//get和set不能和writable和value同时出现---&gt;数据描述符和存取描述符不能混合使用</span></div><div class="line">  get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</div><div class="line">  &#125;,<span class="comment">//当前用户获取属性值就会触发这个方法,并且获取的属性值就是get函数返回值</span></div><div class="line">  set:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>._name=value;</div><div class="line">  &#125;,<span class="comment">//当前用户赋值的时候,触发方法,value就是用户赋值内容,也可不接受参数,然后设置固定值</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>赋值运算符:基于右值的值给左值赋值;</p>
<p>补充:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果 freeze 可用, 防止代码添加或删除对象原型的属性</span></div><div class="line">(<span class="built_in">Object</span>.freeze||<span class="built_in">Object</span>)(<span class="built_in">Object</span>.prototype);</div></pre></td></tr></table></figure>
<p>​</p>
<h3 id="函数的调用模式"><a href="#函数的调用模式" class="headerlink" title="函数的调用模式"></a>函数的调用模式</h3><p><strong>每个函数都有this,函数中this的指向跟函数的调用模式有关系!(全局也有一个this指向window)</strong></p>
<ol>
<li><p>函数调用模式</p>
<p>函数名();</p>
<p>this:指向window对象;</p>
</li>
<li><p>方法调用模式</p>
<p>对象.方法名();  对象<a href="">“方法名”</a>;</p>
<p>this–&gt;指向调用该方法的对象;</p>
</li>
<li><p>构造函数调用模式</p>
<p>new  函数名();</p>
<p>this—&gt;指向新创建的对象;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//面试题</span></div><div class="line"><span class="keyword">var</span> length=<span class="number">100</span>;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">  length:<span class="number">10</span>,</div><div class="line">  func:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.length);</div><div class="line">&#125;</div><div class="line">obj.func(test,<span class="number">100</span>);<span class="comment">//2</span></div><div class="line"></div><div class="line"> <span class="comment">//example2:</span></div><div class="line">  <span class="keyword">var</span> pattern = &#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'I alway return this string,whatever you have assigned'</span>;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.myname = <span class="string">'this is my name string'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">TestDefineSetAndGet</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'myproperty'</span>, pattern);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> instance = <span class="keyword">new</span> TestDefineSetAndGet();</div><div class="line">  instance.myproperty = <span class="string">'test'</span>;</div><div class="line">  <span class="keyword">delete</span> instance.myproperty;<span class="comment">//无法删除 enumerable为false</span></div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(instance.myproperty);<span class="comment">//'I alway return this string,whatever you have assigned'</span></div><div class="line">  <span class="built_in">console</span>.log(instance.myname);<span class="comment">//'this is my name string'</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>上下文调用模式</p>
<p>上下文:环境,语境,</p>
<p>每个函数中的this,这个this指向的就是函数的执行上下文—&gt;执行环境;</p>
<p>上下文调用模式,就是指可以对上下文进行更改的调用模式</p>
<p>上下文调用模式的两种方法:</p>
<p>​    <strong>Function.prototype.call():传参个数确定时用call</strong></p>
<p>​    让一些内置对象的方法拿出来给别人用,比如伪数组无法使用数组的方法,但是用call就可以用数组的方法—&gt;Array.prototype.方法名.call(伪数组);—&gt;伪数组就可以使用这个方法了.</p>
<p><strong>熟记call和apply功能的实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//call()语法 函数名.call(obj,arg1,arg2...);</span></div><div class="line">	<span class="comment">//obj:想让函数被调用的时候,this指向谁,那么这个对象就传入谁.</span></div><div class="line">	<span class="comment">//arg1...argn:指的就是给函数传递的实参</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  consolelog(a,b)</div><div class="line">&#125;</div><div class="line">test.call(&#123;<span class="attr">name</span>:<span class="string">"hcc"</span>&#125;,<span class="number">1</span>,<span class="number">2</span>);</div><div class="line"><span class="comment">//功能:</span></div><div class="line">	<span class="comment">//1.调用了这个函数test;</span></div><div class="line">	<span class="comment">//2.把函数中的this指向对象&#123;name:"hcc"&#125;;</span></div><div class="line">	<span class="comment">//3.把第二个及后面的参数作为实参传给函数;</span></div></pre></td></tr></table></figure>
<p><strong>Function.prototype.apply():要参数个数不确定(动态生成的时候),用apply方法</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//语法:函数名.apply(obj,数组/伪数组);</span></div><div class="line"><span class="comment">//跟call的区别是传参形式不一样,参数个数不确定时,用apply</span></div><div class="line">test.apply(&#123;<span class="attr">name</span>:<span class="string">"hcc"</span>&#125;,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"><span class="comment">//功能:</span></div><div class="line">	<span class="comment">//1.调用这个函数test;</span></div><div class="line">	<span class="comment">//2.把this指向对象&#123;name:"hcc"&#125;;</span></div><div class="line">	<span class="comment">//3.把数组/伪数组中的元素拆开,作为实参依次传给函数.</span></div></pre></td></tr></table></figure>
<p>上下文调用模式注意事项:</p>
<p>1).test.call()—&gt;如果不给call或者apply传递参数,或者传递null  undefined,则默认指向window.</p>
<p>2).test.call(12)—&gt;如果传入值类型,会自动转成对应的引用类型,this指向引用类型.</p>
<h5 id="上下文模式的实际应用"><a href="#上下文模式的实际应用" class="headerlink" title="上下文模式的实际应用:"></a>上下文模式的实际应用:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//应用场景:</span></div><div class="line"><span class="keyword">var</span> obj=&#123;&#125;;</div><div class="line">obj.toString();<span class="comment">//[object Object]</span></div><div class="line"><span class="keyword">var</span> arr=[];</div><div class="line">arr.toString();<span class="comment">//空,数组直接调用的是自己原型中的tostring方法,所以要调用Object的toString方法.如下</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(arr);<span class="comment">//[object Array];</span></div><div class="line"></div><div class="line"><span class="comment">//伪数组转化为真数组</span></div><div class="line"></div><div class="line"><span class="comment">//数组push方法:</span></div><div class="line"><span class="keyword">var</span> fakeArr=&#123;</div><div class="line">  <span class="number">0</span>:<span class="number">1</span>,</div><div class="line">  <span class="number">1</span>:<span class="number">2</span>,</div><div class="line">  length:<span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> realArr=[];</div><div class="line">realArr.push.apply(realArr,fakeArr);</div><div class="line"><span class="comment">//调用realArr.push方法---&gt;更改this为realArr---&gt;把fakeArr的元素拆解开,依次传递给realArr.push方法作为实参;</span></div><div class="line"><span class="comment">//等效的调用方法:realArr.push(fakeArr[0],fakeArr[1]...);</span></div><div class="line"></div><div class="line"><span class="comment">//数组concat方法:</span></div><div class="line"><span class="comment">//(concat()参数是单个数值时,默认是单个数值的数组;--&gt;arr.concat(1,2,3)形同arr.concat([1],[2],[3]);</span></div><div class="line">realArr=realArr.concat.apply(realArr,fakeArr);</div><div class="line"></div><div class="line"><span class="comment">//数组slice()方法:</span></div><div class="line"><span class="keyword">var</span> realArr=<span class="built_in">Array</span>.prototype.slice.call(fakeArr);</div><div class="line"></div><div class="line"><span class="comment">//数组求最大值</span></div><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr);</div><div class="line"></div><div class="line"><span class="comment">//使用call方法调用函数并且指定上下文的'this'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> reply = [<span class="keyword">this</span>.person, <span class="string">'Is An Awesome'</span>, <span class="keyword">this</span>.role].join(<span class="string">' '</span>);</div><div class="line">  <span class="built_in">console</span>.log(reply);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> i = &#123;</div><div class="line">  person: <span class="string">'Douglas Crockford'</span>, <span class="attr">role</span>: <span class="string">'Javascript Developer'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">greet.call(i); <span class="comment">// Douglas Crockford Is An Awesome Javascript Developer</span></div><div class="line"></div><div class="line"><span class="comment">//使用call方法调用匿名函数</span></div><div class="line"><span class="keyword">var</span> animals = [</div><div class="line">  &#123;<span class="attr">species</span>: <span class="string">'Lion'</span>, <span class="attr">name</span>: <span class="string">'King'</span>&#125;,</div><div class="line">  &#123;<span class="attr">species</span>: <span class="string">'Whale'</span>, <span class="attr">name</span>: <span class="string">'Fail'</span>&#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; animals.length; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; </div><div class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'#'</span> + i  + <span class="string">' '</span> + <span class="keyword">this</span>.species + <span class="string">': '</span> + <span class="keyword">this</span>.name); </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">this</span>.print();</div><div class="line">  &#125;).call(animals[i], i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.price = price;</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (price &lt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="built_in">RangeError</span>(<span class="string">'Cannot create product '</span> +</div><div class="line">          <span class="keyword">this</span>.name + <span class="string">' with a negative price'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</div><div class="line">    Product.call(<span class="keyword">this</span>, name, price);</div><div class="line">    <span class="keyword">this</span>.category = <span class="string">'food'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//等同于</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.price = price;</div><div class="line">    <span class="keyword">if</span> (price &lt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="built_in">RangeError</span>(<span class="string">'Cannot create product '</span> +</div><div class="line">          <span class="keyword">this</span>.name + <span class="string">' with a negative price'</span>);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">this</span>.category = <span class="string">'food'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//function Toy 同上</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Toy</span>(<span class="params">name, price</span>) </span>&#123;</div><div class="line">    Product.call(<span class="keyword">this</span>, name, price);</div><div class="line">    <span class="keyword">this</span>.category = <span class="string">'toy'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> cheese = <span class="keyword">new</span> Food(<span class="string">'feta'</span>, <span class="number">5</span>);</div><div class="line">  <span class="keyword">var</span> fun = <span class="keyword">new</span> Toy(<span class="string">'robot'</span>, <span class="number">40</span>);</div></pre></td></tr></table></figure>
<h5 id="两种创建对象的模式"><a href="#两种创建对象的模式" class="headerlink" title="两种创建对象的模式"></a>两种创建对象的模式</h5><ol>
<li><p>工厂模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> obj=&#123;</div><div class="line">    name:name,</div><div class="line">    age:age</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//指向window</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p=creatPerson(<span class="string">"hcc"</span>,<span class="number">18</span>);</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>寄生模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> obj=&#123;&#125;;</div><div class="line">  obj.name=name;</div><div class="line">  obj.age=age;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//new出来的对象</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/16/notes/" data-id="cj6f4qqab0000y8rh6r18ckrw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OO/">OO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/">notes</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/08/16/push-pic/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">push pic</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/intro/">intro</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/notes/">notes</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/notes/OO/">OO</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/test/">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OO/">OO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/intro/">intro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notes/">notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ready-go/">ready go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/OO/" style="font-size: 10px;">OO</a> <a href="/tags/intro/" style="font-size: 10px;">intro</a> <a href="/tags/notes/" style="font-size: 10px;">notes</a> <a href="/tags/ready-go/" style="font-size: 10px;">ready go</a> <a href="/tags/test/" style="font-size: 10px;">test</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/16/notes/">&#39;notes&#39;</a>
          </li>
        
          <li>
            <a href="/2017/08/16/push-pic/">push pic</a>
          </li>
        
          <li>
            <a href="/2017/08/16/welcome-to-my-world/">welcome to my world</a>
          </li>
        
          <li>
            <a href="/2017/08/16/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 leivy.D<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>